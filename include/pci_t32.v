// generated by me Wed Oct 10 12:42:52 2012

//`timescale 1ns/1ns
`timescale 1ns/1ns

module pci_t32 (pci_io, frame_, c_be_, irdy_, trdy_, 
		    devsel_, serr_, rst_, valid_pci, 
		    a_d, ad_from_tuvv, ad_to_tuvv, tuvv_ready, valid_tuvv, pci_busy, rd_wr, clk, dip_a);
    inout [31:0] pci_io; //shina PCI
    input frame_;
    input [3:0] c_be_;
    input irdy_;
    output trdy_;
    output devsel_;
    output serr_;
    input rst_;
    output valid_pci; //signal "dostupnie dannie" (strob)
    output a_d; //signal adres/dannie (adres "0" dannie "1")
    input [31:0]ad_from_tuvv; //vhodnaja shina PCI kontrollera ot TUVV2
    output [31:0]ad_to_tuvv; //vihodnaja shina PCI kontrollera k TUVV2
    input tuvv_ready; //signal gotovnosti TUVV2
    input valid_tuvv; //signal vidachi dannih iz TUVV2
    output pci_busy; //signal zanatosti mastera
    output rd_wr;
    input clk;
	input [3:0] dip_a;
    
    wire [31:0]pci_io;
    wire frame_;
    wire frame_in;
    wire [3:0] c_be_;
    wire [3:0] c_be_in;
    wire irdy_;
    wire irdy_in;
    wire trdy_;
    wire devsel_;
    wire serr_;
    wire rst_;
    wire valid_pci;
    wire valid_tuvv;
    reg a_d;
    wire [31:0]ad_from_tuvv;
    reg [31:0]pci_bufreg;
    wire tuvv_ready;
    wire pci_busy;
    wire transaction;
    wire rd_wr; //signal zapisi/chtenija iz/v TUVV2 ("1" - "write", "0" - "read")
    wire clk;
    wire devsel_in;
    
    wire [31:0]ad_pciin;
    wire slave_working;
    wire adress_phase;
    reg data_phase;
    wire wr_from_pci;
    wire rd_to_pci;
    wire err_op_pci;
    reg err_op_pci_n; //signal otkritija bufera na vihod (dla utazhki shini vverh)
    wire trdy_out;
    wire devsel_out;
    wire wr_adr_from_pci_flg;
    wire wr_dat_from_pci_flg;
    wire rd_dat_to_pci_flg;
    wire adr_ready;
    reg adr_ready_flg;
    reg data_ready;
    reg [3:0]command_pci_in;
    reg trdy_out_n; //signal otkritija bufera na vihod (dla utazhki shini vverh)
    reg devsel_out_n; //signal otkritija bufera na vihod
    wire wr_tuvv_bufr;

	integer delay;	  
    
    
    initial
	begin
		delay = 0;
	    a_d <= 1'b0; 
	    pci_bufreg[31:0] <= 32'b0;
	    adr_ready_flg <= 1'b0;
	    data_ready <= 1'b0;
	    command_pci_in[3:0] <= 4'b1;
	    data_phase <= 1'b0;
	    devsel_out_n <= 1'b0;
	    trdy_out_n <= 1'b0;
	    err_op_pci_n <= 1'b0;	
	end
//IN_OUT PCI Signals
assign pci_io[31:0] = (wr_tuvv_bufr) ? ad_from_tuvv[31:0] : 32'hz;
assign ad_pciin[31:0] = pci_io[31:0];

assign frame_in = frame_;
	 
assign c_be_in = c_be_; 

assign irdy_in = irdy_;

//assign trdy_ = (trdy_out || trdy_out_n) ? !trdy_out : 1'bz; //zaderzhannoe otkluchenie vihodnogo bufera
assign trdy_ = (trdy_out || trdy_out_n) ? !trdy_out : 1'b1; //zaderzhannoe otkluchenie vihodnogo bufera
//assign devsel_ = (devsel_out || devsel_out_n) ? !devsel_out : 1'bz; //zaderzhannoe otkluchenie vihodnogo bufera
assign devsel_ = (devsel_out || devsel_out_n) ? !devsel_out : 1'b1; //zaderzhannoe otkluchenie vihodnogo bufera

assign devsel_in = devsel_;
assign serr_ = (err_op_pci || err_op_pci_n) ? !err_op_pci : 1'bz;

assign ad_to_tuvv[31:0] = (pci_bufreg[31:0] & {32{valid_pci}}); //| (fifo_out[31:0] & {32{valid_pci && !a_d}});

//SLAVE WORK
//assign slave_working = adress_phase | data_phase | trdy_out;

assign rd_wr = command_pci_in[0];
assign wr_from_pci = command_pci_in[0]; //zapis v kontroller (operacija)
assign rd_to_pci = !command_pci_in[0]; //chtenie iz kontrollera (operacija)	
assign err_op_pci = ((c_be_in[3] || !c_be_in[2] || !c_be_in[1]) && adress_phase); //oshibka (nedopustimaja komanda)
assign devsel_out = data_phase; //kontroller vibran

assign adress_phase = (!frame_in && irdy_in && (devsel_in!==1'b0) && (ad_pciin[29] == 1'b1) && (ad_pciin[27:24] == 4'b0011) && (ad_pciin[1:0] == 2'b00) && rst_); //start raboti slave po prihodu frame i esli adres sluchayno ne javlaetsa ch`imi-to dannimi
//assign adress_phase = (!frame_in && irdy_in && (ad_pciin[29] == 1'b1) && (ad_pciin[27:24] == 4'b0011) && (ad_pciin[1:0] == 2'b00) && rst_); //start raboti slave po prihodu frame i esli adres sluchayno ne javlaetsa ch`imi-to dannimi
assign wr_adr_from_pci_flg = adress_phase && !err_op_pci;
assign wr_dat_from_pci_flg = (wr_from_pci && data_phase); // zapis dannih s shini PCI
assign rd_dat_to_pci_flg = (rd_to_pci && data_phase); //chtenie dannih iz kontrollera

assign pci_busy = !frame_in && irdy_in;
assign transaction = data_phase && !(frame_in && irdy_in);

//chtenie/zapis dannih iz/v kontroller
assign valid_pci = adr_ready || data_ready;

assign wr_tuvv_bufr = (rd_dat_to_pci_flg && valid_tuvv && transaction);

always @ (posedge clk)
	begin
	    if(!rst_) data_phase <= #delay 1'b0;
	    else if (adress_phase && !err_op_pci) data_phase <= #delay 1'b1; //zapusk raboti kontrollera
	    else if (data_phase && frame_in && irdy_in) data_phase <= #delay 1'b0;
	    /*
	    if (data_phase && !tuvv_ready) wait_cnt <= #delay wait_cnt + 1'b1; 
	    else wait_cnt <= #delay 1'b0; 
	    */
	end

assign adr_ready = adr_ready_flg && tuvv_ready; //ozhidanie gotovnosti TUVV2 dla prinatija adresa
always @ (posedge clk)
	begin
	    if(!rst_)
			begin
				command_pci_in[3:0] <= #delay 4'b0;
				pci_bufreg[31:0] <= #delay 32'b0;
				adr_ready_flg <= #delay 1'b0;
				data_ready <= #delay 1'b0;
				a_d <= #delay 1'b0;
			end
	    else if (wr_adr_from_pci_flg) 
			begin
				command_pci_in[3:0] <= #delay c_be_in[3:0]; //zapis prihodashej komandi?
				pci_bufreg[31:0] <= #delay ad_pciin[31:0]; //zapis prihodashego adresa
				a_d <= #delay 1'b1;
				adr_ready_flg <= #delay 1'b1;
			end
	    else if(wr_dat_from_pci_flg && trdy_out) //zapis dannih v TUVV2
			begin
				pci_bufreg[31:0] <= #delay ad_pciin[31:0];
				data_ready <= #delay 1'b1;
			end
	    else if(adr_ready) //sbrasivaem flag adresa i perevodim signal "a_d" v fazu dannih po prihodu signala gotovnosti TUVV2
			begin
				adr_ready_flg <= #delay 1'b0;
				a_d <= #delay 1'b0;
			end
	    else 
			begin	
				data_ready <= #delay 1'b0;
			end	  
	end
//chtenie/zapis dannih iz/v kontroller	
//----------------------------------------------------------//

always @ (negedge clk)
	begin
	    trdy_out_n <= #delay trdy_out;
	    devsel_out_n <= #delay devsel_out;
	    err_op_pci_n <= #delay err_op_pci;
	end

assign trdy_out = (wr_dat_from_pci_flg) ? (data_phase && !irdy_in && tuvv_ready && !adr_ready_flg && !data_ready) : (rd_dat_to_pci_flg) ? (data_phase && !(frame_in && irdy_in) && !adr_ready_flg && wr_tuvv_bufr) : 1'b0;

/*
always @ (posedge clk) //formirovanie stroba "TRDY"
	begin
	    if (!rst_) trdy_out <= #delay 1'b0;
	    else if (data_phase &&  !irdy_in && !adr_ready_flg && !data_ready && tuvv_ready && wr_dat_from_pci_flg && !trdy_out) trdy_out <= #delay 1'b1; 
	    else if (data_phase && !irdy_in && !adr_ready_flg && wr_tuvv_bufr && rd_dat_to_pci_flg && !trdy_out) trdy_out <= #delay 1'b1;
	    else trdy_out <= #delay 1'b0;
	end
*/

/*
always @ (posedge clk) //formirovanie stroba "TRDY"
	begin
	    if (!rst_) trdy_out <= #`delay 1'b0;
	    else if (data_phase && !(frame_in && irdy_in) && tuvv_ready && !fifo_almost_full && !fifo_full && wr_dat_from_pci_flg) trdy_out <= #`delay 1'b1; 
	    else if (data_phase && !(frame_in && irdy_in) && valid_tuvv && rd_dat_to_pci_flg) trdy_out <= #`delay 1'b1;
	    else trdy_out <= #`delay 1'b0;
	end  
*/

endmodule
